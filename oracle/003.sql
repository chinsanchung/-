--퀴즈: 컬럼 1, 2 를 기본키로 만들어라
CREATE TABLE T_TEST01 (
    COL1 NUMBER NOT NULL,
    DOL2 CHAR(2) NOT NULL,
    COL3 VARCHAR2(10)
);
ALTER TABLE T_TEST01
    ADD CONSTRAINT PK_T_TEST01 PRIMARY KEY (COL1, COL2);
--ADD CONSTRAINTS PK_COL1 PRIMARY KEY (COL1) 내가한거

UPDATE T_TEST01
    SET COL2
FROM DOL2;

CREATE TABLE T_TEST02(
    COL1 NUMBER NOT NULL,
    COL2 CHAR(2) NOT NULL,
    COL3 NUMBER NOT NULL,
    COL4 VARCHAR(10)
);

ALTER TABLE T_TEST02
    ADD CONSTRAINT PK_T_TEST2 PRIMARY KEY (COL1, COL2, COL3);
--조인하기
--우선 외래키..테스트2가 참조하는 테이블. COL1, COL2가 테스트01의 COL1, COL2 참조.
ALTER TABLE T_TEST02
    ADD CONSTRAINT FK_T_TEST02_TO_T_TEST01 FOREIGN KEY (COL1, COL2)
    REFERENCES T_TEST01(COL1, COL2);
--확인해보기. 테스트2의 P(기본키), R(외래키)이다.
SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'T_TEST02';
SELECT *
FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'T_TEST02';

--WHERE할때 모호성 안생기게 A.테이블네임..만약 제약조건이 기억이 안나면 이걸로 확인을 해보기
SELECT B. COLUMN_NAME, A.CONSTRAINT_NAME, A.CONSTRAINT_TYPE, A.SEARCH_CONDITION, A.R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS A JOIN USER_CONS_COLUMNS B ON (A.CONSTRAINT_NAME= B.CONSTRAINT_NAME)
WHERE A.TABLE_NAME = 'T_TEST02';

--데이터 넣기..TEST01부터 넣어야(참조되는 테이블이니까)
DESC T_TEST01;
DESCRIBE T_TEST01; --확인

INSERT INTO T_TEST01(COL1, COL2)
VALUES(1, 'A1');
INSERT INTO T_TEST01(COL1, COL2)
VALUES(1, 'B1');
SELECT * FROM T_TEST01;
INSERT INTO T_TEST01(COL1, COL2)
VALUES(2, 'A2');
INSERT INTO T_TEST01(COL1, COL2)
VALUES(2, 'B2');
INSERT INTO T_TEST01(COL1, COL2)
VALUES(2, 'C2');
COMMIT;
DESC T_TEST02
INSERT INTO T_TEST02
VALUES(1, 'A1', 100, '1-A1-100');
SELECT * FROM T_TEST02;
INSERT INTO T_TEST02
VALUES(1, 'A1', 110, '1-A1-110');
INSERT INTO T_TEST02
VALUES(1, 'B1', 100, '1-B1-100');
INSERT INTO T_TEST02
VALUES(1, 'B1', 110, '1-B1-110');
--무결성 제약조건 위배때문에 2,'A1' 을 2,'A2'로 바꿈
INSERT INTO T_TEST02
VALUES(2, 'A2', 100, '2-A2-100');
COMMIT;
--CHECK 제약
ALTER TABLE T_TEST02
    ADD COL5 NUMBER;

DESC T_TEST02;

ALTER TABLE T_TEST02
    ADD CONSTRAINT CK_T_TEST02_COL5 CHECK(COL5 > 100);
INSERT INTO T_TEST02(COL1, COL2, COL3, COL4, COL5)
VALUES(2, 'B2', 100, '2-B2-100', 5000);
SELECT * FROM T_TEST01;

INSERT INTO T_TEST02(COL1, COL2, COL3, COL4, COL5)
VALUES(3, 'A3', 100, '3-A3-100', 150);
INSERT INTO T_TEST01(COL1, COL2)
VALUES(3, 'A3');

INSERT INTO T_TEST02(COL1, COL2, COL3, COL4, COL5)
VALUES(3, 'B3', 110, '3-B3-110', 50);

--테이블 제거하기..TEST01할시 외래키에 의해 참조되는 고유/기본키가 테이블에 있다고 뜬다
--PURGE로 휴지통에 가지 않게 완전삭제가능하다
DROP TABLE T_TEST02 PURGE;
DROP TABLE T_TEST01 PURGE;

--간단한 연습
CREATE TABLE T_TEST_RECYCLEBIN (
    COL1 NUMBER(3) NOT NULL
);
DROP TABLE T_tEST_RECYCLEBIN;
-- 휴지통에 있는걸 복원하기
FLASHBACK TABLE T_TEST_RECYCLEBIN TO BEFORE DROP;
--완전삭제 방법 2
DROP TABLE T_TEST_RECYCLEBIN;
PURGE TABLE T_TEST_RECYCLEBIN;
SHOW RECYCLEBIN;--휴지통에 있음을 확인
PURGE RECYCLEBIN; --테이블 하나 지우는게 아닌 통째로 지운다

--컬럼명 바꾸자
CREATE TABLE T_TEST00 (
    COL1 NUMBER(3) NOT NULL
);
ALTER TABLE T_TEST00
    ADD COL2 VARCHAR2(10);  --컬럼 추가
DESC T_TEST00;  --컬럼 추가 확인하는 빠른 방법
ALTER TABLE T_TEST00
    MODIFY COL2 VARCHAR2(20);
ALTER TABLE T_TEST00
    MODIFY COL2 NOT NULL;
ALTER TABLE T_TEST00
    MODIFY COL2 NULL;
ALTER TABLE T_TEST00
    RENAME COLUMN COL2 TO COL02; 
ALTER TABLE T_TEST00
    DROP COLUMN COL02;  --컬럼 삭제
--테이블 생성 중 테이블 구조만 복사
SELECT COUNT(*)
FROM EMPLOYEES;  
SELECT JOB_ID, COUNT(*) FROM EMPLOYEES GROUP BY JOB_ID;

--WHERE할때 모호성 안생기게 A.테이블네임..만약 제약조건이 기억이 안나면 이걸로 확인을 해보기
SELECT A.TABLE_NAME, B.COLUMN_NAME, A.CONSTRAINT_NAME, A.CONSTRAINT_TYPE, A.SEARCH_CONDITION,
A.R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS A JOIN USER_CONS_COLUMNS B ON (A.CONSTRAINT_NAME = B. CONSTRAINT_NAME)
WHERE A.TABLE_NAME = 'T_RECEIPT_DETAIL_COPY';
--2-1의 데이터까지 복사하기. 
CREATE TABLE EMPLOYEES_COPY_WTIH_DATA
AS
SELECT *
FROM EMPLOYEES;
--2-2 복사. WHERE의 FALSE로 인해 구조, 메타구조만 복사하게 된다. 데이터는 못가져온다.
CREATE TABLE EMPLOYEES_COPY_WITHOUT_DATA
AS
SELECT *
FROM EMPLOYEES WHERE 1=0;

SELECT * FROM EMPLOYEES_COPY_WITHOUT_DATA;

CREATE TABLE T_RECEIPT_DETAIL_COPY
AS
SELECT *
FROM T_RECEIPT_DETAIL;
DROP TABLE T_RECIPT_DETAIL_COPY;
--VIEW 알아보기..아래 코드를 매번 짜는건 힘드니까..
SELECT A.TABLE_NAME, B.COLUMN_NAME, A.CONSTRAINT_NAME, A.CONSTRAINT_TYPE, A.SEARCH_CONDITION,
A.R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS A JOIN USER_CONS_COLUMNS B ON (A.CONSTRAINT_NAME = B. CONSTRAINT_NAME);
--이러케 만들어봐
CREATE OR REPLACE VIEW V_CONSTRAINTS_COLUMNS AS 
SELECT A.TABLE_NAME, B.COLUMN_NAME, A.CONSTRAINT_NAME, A.CONSTRAINT_TYPE, A.SEARCH_CONDITION,
A.R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS A JOIN USER_CONS_COLUMNS B ON (A.CONSTRAINT_NAME = B. CONSTRAINT_NAME);

SELECT * FROM V_CONSTRAINTS_COLUMNS WHERE TABLE_NAME= 'T_RECEIPT_DETAIL';
--뷰 삭제
DROP VIEW V_CONSTRAINTS_COLUMNS;

--뷰에 대한 정보 보기
SELECT * FROM DICTIONARY WHERE UPPER(TABLE_NAME) LIKE 'USER%' 
AND LOWER(COMMENTS) LIKE '%view%';
SELECT * FROM USER_VIEWS;

--인덱스
SELECT DISTINCT CUST_NAME FROM CUSTOMERS;
SELECT * FROM CUSTOMERS WHERE CUST_NAME = 'Ashton Kennedy';
--인덱스 만들기
CREATE INDEX IX_CUSTOMERS_CUST_NAME ON CUSTOMERS(CUST_NAME);
--인덱스 지우기
DROP INDEX IX_CUSTOMERS_CUST_NAME;

SELECT* FROM USER_INDEXES WHERE TABLE_NAME='CUSTOMERS';

--시노님 만들기 원래이름 CUSTOMERS에 동의어 CUST 만듬
CREATE OR REPLACE SYNONYM CUST
FOR CUSTOMERS;
SELECT * FROM CUST;
--프라이빗 시노님 권한을 HR에 주기
GRANT SELECT ON CUST TO HR;
--권한 뺐기
REVOKE SELECT ON CUST FROM HR;
--퍼블릭 시노님
CREATE OR REPLACE PUBLIC SYNONYM CUST FOR CUSTOMERS;
GRANT SELECT ON CUST TO PUBLIC;
-- 시노님 없애기
DROP SYNONYM CUST;
DROP PUBLIC SYNONYM CUST;
--시퀀스 만들기
CREATE TABLE T_SEQ_TEST(
    COL1 NUMBER(1) PRIMARY KEY
);
--1씩 증가, 1부터 시작, 최소 1 최대 9. 디폴트값으로 최대나 최소값에 도달하면 생성 중지. 디폴트로 메모리에 시퀸스 값 할당X
CREATE SEQUENCE SEQ_T_SEQ_TEST
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9
NOCYCLE 
NOCACHE;
--
INSERT INTO T_SEQ_TEST(COL1)
VALUES(SEQ_T_SEQ_tEST.NEXTVAL);
INSERT INTO T_SEQ_TEST(COL1)
VALUES(SEQ_T_SEQ_tEST.NEXTVAL);

SELECT * FROM T_SEQ_TEST;

DROP SEQUENCE SEQ_T_SEQ_TEST;
--시퀀스 다시 만들기...
CREATE SEQUENCE SEQ_T_SEQ_TEST
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 9
NOCYCLE 
NOCACHE;
--실패하게 만드는중
ALTER TABLE T_SEQ_TEST MODIFY COL2 NUMBER(6);
INSERT INTO T_SEQ_TEST(COL1, COL2)
VALUES(SEQ_T_SEQ_tEST.NEXTVAL, 10);
--로그 안남기는 DDL. 롤백이 안된다
TRUNCATE TABLE T_SEQ_TEST;

--HR에 붙여넣기
--SELECT * 
--FROM ORA_USER.CUST;
--둘은 동의어
--SELECT * FROM ORA_USER.CUSTOMERS;
--퍼블릭으로 하면 앞에 스키마정보(ORA_USER.)이 필요없다
--SELECT * FROM CUST;
--대신 퍼블릭으로 하면 CUSTOMERS로는 안된다.