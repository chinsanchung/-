--1. 의사 컬럼..ROWID는 물리적으로 존재.
SELECT ROWID, ROWNUM, EMPLOYEE_ID, EMP_NAME
FROM EMPLOYEES;
--ROWID로 검색하면 프라이머리키로 검색한 것과 같다. 코스트가 가장 낮아도 로아디 외우기 힘들어
SELECT ROWID, ROWNUM, EMPLOYEE_ID, EMP_NAME
FROM EMPLOYEES WHERE ROWID = 'AAASNaAAGAAAAC1AAA';
--ROWNUM은 계속 바뀐다  셀렉트한 결과에 붙이는 숫자값.
SELECT ROWNUM, EMPLOYEE_ID, EMP_NAME
FROM (SELECT ROWNUM, EMPLOYEE_ID, EMP_NAME
FROM EMPLOYEES ORDER BY EMP_NAME) A;
--1-2. ROWNUM..TOP-N SQL 활용, 급여 탑 10 조회하기
SELECT ROWNUM, EMPLOYEE_ID, EMP_NAME, SALARY
FROM (SELECT ROWNUM, EMPLOYEE_ID, EMP_NAME, SALARY
FROM EMPLOYEES ORDER BY SALARY DESC) A
WHERE ROWNUM <= 10;
--2. 표현식 예제.. 급여 5000 이하 C, 급여 5000 초과 15000 미만 B, 15000 초과 A
SELECT EMPLOYEE_ID, EMP_NAME, SALARY,
        CASE WHEN SALARY > 15000 THEN 'A'
             WHEN SALARY <= 15000 AND SALARY > 5000 THEN 'B'
             ELSE 'C' 
        END "GRADE"
FROM EMPLOYEES;
--2.2 표현식 문제. CUSTOMER에서 나이 정보 알고-> 70 이상 노인, 55 이상 장년, 40 이상 중년, 20 이상 청년, 10 이상 소년 10세 미만 아동
--CASE WHEN 활용
SELECT CUST_ID, CUST_NAME, CUST_YEAR_OF_BIRTH,
       TO_CHAR(CUST_YEAR_OF_BIRTH)
FROM CUSTOMERS;

SELECT CUST_ID, CUST_NAME, CUST_YEAR_OF_BIRTH, AGE,
       CASE WHEN AGE > 70 THEN '노인'
            WHEN AGE < 70 AND AGE >= 55 THEN '장년'
            WHEN AGE < 55 AND AGE >= 40 THEN '중년'
            WHEN AGE < 40 AND AGE >= 20 THEN '청년'
            WHEN AGE < 20 AND AGE >= 10 THEN '소년'
       ELSE '아동'
       END "세대"
       --아래 인라인뷰는 임시..많이 쓰인다면 아예 뷰로 만들어버리기
FROM (SELECT CUST_ID, CUST_NAME, CUST_YEAR_OF_BIRTH,
             FLOOR(MONTHS_BETWEEN(SYSDATE, TO_DATE(TO_CHAR(CUST_YEAR_OF_BIRTH) || '-01-01', 'YYYY-MM-DD')) / 12) "AGE"
      FROM CUSTOMERS);
--인라인 뷰를 뷰로 만들어버리기
CREATE OR REPLACE VIEW V_CUST_AGE
AS
SELECT CUST_ID, CUST_NAME, CUST_YEAR_OF_BIRTH,
             FLOOR(MONTHS_BETWEEN(SYSDATE, TO_DATE(TO_CHAR(CUST_YEAR_OF_BIRTH) || '-01-01', 'YYYY-MM-DD')) / 12) "AGE"
FROM CUSTOMERS;
--SELECT CUST_ID, CUST_NAME, CUST_YEAR_OF_BIRTH, AGE,
--       CASE WHEN AGE > 70 THEN '노인'
--            WHEN AGE < 70 AND AGE >= 55 THEN '장년'
--            WHEN AGE < 55 AND AGE >= 40 THEN '중년'
--            WHEN AGE < 40 AND AGE >= 20 THEN '청년'
--            WHEN AGE < 20 AND AGE >= 10 THEN '소년'
--       ELSE '아동'
--       END "세대"
--FROM V_CUST_AGE; 뷰를 만들면 FROM칸들 줄일 수 있다.
--3. 114쪽 조건식 알기
SELECT EMPLOYEE_ID, EMP_NAME, SALARY 
FROM EMPLOYEES 
WHERE SALARY = 2600 OR SALARY = 6000 OR SALARY = 10000;
-->조건식.. ALL은 등호 =가 아니라 부호 >, < 를 쓸 때 의미있음
SELECT EMPLOYEE_ID, EMP_NAME, SALARY 
FROM EMPLOYEES 
WHERE SALARY > ALL(2600, 600, 10000);  -->, < ANY는 값 하나만 충족되도 됨
--논리 조건식 NOT..되도록 쓰지 말래. NOT 쓰면 인덱스 불가능
SELECT EMPLOYEE_ID, EMP_NAME, SALARY 
FROM EMPLOYEES 
WHERE NOT (SALARY > 2500); --> WHERE SALARY <= 2500;

SELECT EMPLOYEE_ID, EMP_NAME, SALARY 
FROM EMPLOYEES 
WHERE SALARY BETWEEN 3000 AND 5000; -- = SALARY >= 3000 AND SALARY <= 5000;

SELECT EMPLOYEE_ID, EMP_NAME, SALARY 
FROM EMPLOYEES 
WHERE SALARY IN (2600, 6000, 10000);

--4. EXISTS 조건식
--월급이 3000불 이상인 부서의 정보출력
SELECT * FROM EMPLOYEES WHERE SALARY >= 3000;
SELECT * FROM DEPARTMENTS A
WHERE EXISTS (SELECT EMPLOYEE_ID, EMP_NAME, SALARY 
              FROM EMPLOYEES B 
              WHERE B.DEPARTMENT_ID = A.DEPARTMENT_ID
              AND B.SALARY >= 3000); --부서 정보 EXISTS(~행) ~행이 존재하면 SELECT해줘
--위 설명: EXIST 들아건 것은 Co_related Subquery (상호연관서브쿼리)..메인에서 결과를 던져주면 존재여부를 상호연관체크하는 쿼리임
--        메인 a에서 값을 주면 서브쿼리 WHERE에서 B.DEPARTEMNT_ID하고 A.DEPARTMENT_ID 비교..마치 조인처럼 작동
--        EXISTS안의 값이 하나라도 만족하면 TRUE

--4.1 2002년 입사자가 있는 부서 조회하기..(SUBSTR은 0부터 아니라 1부터 시작) SUBSTR로 추출
SELECT HIRE_DATE, SUBSTR( TO_CHAR(HIRE_DATE, 'YYYY-DMM-DD'), 1, 4)  FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS A
WHERE EXISTS (SELECT * 
              FROM EMPLOYEES B 
              WHERE B.DEPARTMENT_ID = A.DEPARTMENT_ID
              AND SUBSTR(TO_CHAR(HIRE_DATE, 'YYYY-MM-DD'), 1, 4) = '2002');

--5. LTRIM(왼쪽) RTRIM(오른쪽) (char, set) char문자열에서 set으로 지정된 문자열을 왼쪽/오른쪽 제거 후 나머지 문자열 반환
SELECT '  홍 길동  ' FROM DUAL;  --이름 앞에 스페이스가 있어서 검색에 어려움
SELECT '  홍 길동  ',LENGTH('  홍 길동  '), LTRIM('  홍 길동  ', '  '), LENGTH(LTRIM('  홍 길동  ', '  ')), 
       RTRIM('  홍 길동  ', '  '), LENGTH(RTRIM('  홍 길동  ', '  ')),
       RTRIM(LTRIM('  홍 길동  ', '  '), '  '),
       LENGTH(RTRIM(LTRIM('  홍 길동  ', '  '), '  '))
FROM DUAL; 

--6. PARENT_ID 100번인 팀..두 개의 셀렉트를 하나로 연결하기  
SELECT DEPARTMENT_NAME
FROM DEPARTMENTS
WHERE DEPARTMENT_ID = 100;
SELECT DEPARTMENT_NAME
FROM DEPARTMENTS
WHERE PARENT_ID = 100;
--에서 바꿈. LPAD: 왼쪽에 12만큼 '-'를 삽입한다+RPAD 오른쪽으로 ' '가 10만큼 이동. LPAD RPAD로 문자열 맞춤
SELECT DEPARTMENT_ID ,DEPARTMENT_NAME FROM DEPARTMENTS WHERE DEPARTMENT_ID = 100
UNION
SELECT DEPARTMENT_ID, LPAD(RPAD(DEPARTMENT_NAME, 10, ' '), 12, '-')
FROM DEPARTMENTS WHERE PARENT_ID = 100;
--6.1 UNION이랑 UNION ALL이랑 다름. UNION은 중복행을 제거, UNION ALL은 두개의 셀렉트를 합치는 일만 한다. 위와 아래 데이터 중복이 없어야한다.
SELECT 1 COL1, 2 COL2, 3 COL3 FROM DUAL
UNION ALL
SELECT 1 COL1, 2 COL2, 3 COL3 FROM DUAL;

--7. REPLACE 함수. 가운데 있는 스페이스도 전부 ''(널 문자열)로 바꿔줌
SELECT '  홍 길동  ', REPLACE('  홍 길동  ', ' ', ''), LENGTH(REPLACE('  홍 길동  ', ' ', ''))
FROM DUAL;

--8. 날짜함수
--NLS_DATE_FORMAT을 YYYY-MM-DD HH24:MI:SS로 바꿈
ALTER SESSION 
SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
SELECT SYSDATE FROM DUAL;

--8.1 오늘 날짜에서 년도, 월, 일 분리해서 꺼내기
SELECT SYSDATE FROM DUAL;
SELECT SUBSTR(SYSDATE, 1, 4), SUBSTR(SYSDATE, 6, 2), SUBSTR(SYSDATE, 9, 2)
FROM DUAL;

--8.2 2017년 08월 02일
SELECT SUBSTR(SYSDATE, 1, 4) || '년' "연", SUBSTR(SYSDATE, 6, 2) ||'월' "월", SUBSTR(SYSDATE, 9, 2) || '일' "일"
FROM DUAL;

--8.3 2017년 8월 2일
SELECT SUBSTR(SYSDATE, 1, 4) || '년' "연", LTRIM(SUBSTR(SYSDATE, 6, 2), '0') ||'월' "월", LTRIM(SUBSTR(SYSDATE, 9, 2), '0') || '일' "일"
FROM DUAL;

--9. ROUND함수..반올림
SELECT ROUND(3.141592, 4) FROM DUAL;
--9.1 정중앙 기준으로 바꿈
SELECT SYSDATE, ROUND(SYSDATE, 'YEAR'), ROUND(SYSDATE, 'MONTH'), ROUND(SYSDATE, 'DAY')
FROM DUAL;

--10. GREATEST함수
SELECT GREATEST(10, 20, 30, 40) FROM DUAL;
--10.1 LEAST함수
SELECT LEAST(10, 20, 30, 40) FROM DUAL;

--11 DECODE는 오라클에서만 쓴다. CASE는 모든데서.
SELECT DECODE(1, 1, '1번입니다.', 2, '2번입니다', 3, '3번입니다', '기타...') "DECODE"
FROM DUAL;

--11.1 COUNT
SELECT COUNT (*) FROM EMPLOYEES;
SELECT COUNT(DEPARTMENT_ID) FROM EMPLOYEES;
SELECT EMPLOYEE_ID, EMP_NAME, DEPARTMENT_ID FROM EMPLOYEES;
SELECT COUNT(NVL(DEPARTMENT_ID, 0))FROM EMPLOYEES;

SELECT NULL + 30000
FROM DUAL;
--11.3 AVG
SELECT COUNT (*), AVG(COMMISSION_PCT) FROM EMPLOYEES WHERE JOB_ID IN ('SA_REP', 'SA_MAN');
SELECT AVG(NVL(COMMISSION_PCT, 0))
FROM EMPLOYEES;
--12. 교재 EMPLOYEE의 DEPARTEMNT 아이디 몇개
SELECT COUNT(DISTINCT DEPARTMENT_ID)
FROM EMPLOYEES; --이건 널값을 카운트 안했음

--12.1 COMMISSION_PCT가 NULL이면 0으로 바꾸고 PCT 값 있으면 SUM으로 더해준다
DESC EMPLOYEES;
SELECT SUM(SALARY + (SALARY * NVL(COMMISSION_PCT, 0)))
FROM EMPLOYEES;

--13. GROUP BY 2013년 지역별 가계대출 총 잔액현황
SELECT * FROM KOR_LOAN_STATUS;
SELECT DISTINCT GUBUN
FROM KOR_LOAN_STATUS;

DESC KOR_LOAN_STATUS;
--방법1
SELECT SUM(LOAN_JAN_AMT)
FROM KOR_LOAN_STATUS
WHERE PERIOD LIKE '2013%';
--방법2
SELECT SUM(LOAN_JAN_AMT)
FROM KOR_LOAN_STATUS
WHERE SUBSTR(PERIOD, 1, 4) = '2013';
--방법3 FBI(Function Based Index). 함수 적용된 자체를 인덱스검
CREATE INDEX IX_KOR_LOAN_STATUS_PERIOD_YEAR ON KOR_LOAN_STATUS(SUBSTR(PERIOD, 1, 4));

SELECT INDEX_NAME, INDEX_TYPE
FROM USER_INDEXES
WHERE TABLE_NAME = 'KOR_LOAN_STATUS';

SELECT REGION, SUM(LOAN_JAN_AMT) TOTAL
FROM KOR_LOAN_STATUS
WHERE SUBSTR(PERIOD, 1, 4) = '2013'
GROUP BY REGION
ORDER BY TOTAL DESC;

--13.1 1년 전체. SUM이 6만 이상...HAVING에서 TOTAL >=~ 못씀
SELECT REGION, SUM(LOAN_JAN_AMT) TOTAL
FROM KOR_LOAN_STATUS
WHERE SUBSTR(PERIOD, 1, 4) = '2013'
GROUP BY REGION
HAVING SUM(LOAN_JAN_AMT) >= 60000
ORDER BY TOTAL DESC;

--13.2 2013년 각 월별, 지역별에 해당하게
SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) TOTAL
FROM KOR_LOAN_STATUS
WHERE SUBSTR(PERIOD, 1, 4) = '2013'
GROUP BY PERIOD, REGION
HAVING SUM(LOAN_JAN_AMT) >= 60000
ORDER BY PERIOD, TOTAL DESC;

--13.3 문제 2013년도 각 지역별 몇월 데이터가 존재하는가
SELECT REGION, PERIOD FROM KOR_LOAN_STATUS;
WHERE PERIOD LIKE '2013%%'
ORDER BY REGION, PERIOD ASC;

SELECT REGION, SUBSTR(PERIOD, 5, 2) "월"
FROM KOR_LOAN_STATUS
WHERE PERIOD LIKE '2013%'
GROUP BY REGION, PERIOD
ORDER BY REGION, PERIOD ASC;

--13.4 ("지역")경북 10, 11 ("월데이터")
--            광주 10, 11
SELECT REGION "지역",
       SUM;

--13.5 2013년 지역별 가계대출 총액의 월별 현황..HINT: CASE WHEN ~THEN ~ELSE ~END 활용 -> SUM() 적용
/*SELECT REGION "지역",
       CASE WHEN SUBSTR(PERIOD, 5, 2) = 10 THEN LOAN_JAN_AMT ELSE 0 END "10월",
       CASE WHEN SUBSTR(PERIOD, 5, 2) = 11 THEN LOAN_JAN_AMT ELSE 0 END "11월"
FROM KOR_LOAN_STATUS WHERE SUBSTR(PERIOD, 1, 4) = '2013';*/
--첫번째 CASE로 2013년 10월, 11 아니면 0으로 만들어버림
--이제 합쳐보기
SELECT REGION "지역",
       SUM(CASE WHEN SUBSTR(PERIOD, 5, 2) = 10 THEN LOAN_JAN_AMT ELSE 0 END) "10월",
       SUM(CASE WHEN SUBSTR(PERIOD, 5, 2) = 11 THEN LOAN_JAN_AMT ELSE 0 END) "11월"
FROM KOR_LOAN_STATUS 
WHERE SUBSTR(PERIOD, 1, 4) = '2013'
GROUP BY REGION
ORDER BY REGION;