--1. 뽑기 프로그램 만들기
--http://docs.oracle.com/cd/E11882_01/appdev.112/e40758/d_random.htm#ARPLS67507
--여기서 VALUE FUCTIONS(FUCTION이라 클라이언트실행이래)
--1.1 1~45
SELECT DBMS_RANDOM.VALUE()  --0 <= X < 1
FROM DUAL;

SELECT DBMS_RANDOM.VALUE(0, 45)  --0 <= X < 45
FROM DUAL;

SELECT FLOOR(DBMS_RANDOM.VALUE(0, 45) + 1)  --1 <= X < 46
FROM DUAL;

--1.2
SELECT DBMS_RANDOM.RANDOM() FROM DUAL;    -2^31 < X < 2^31-1 
--1.3
SELECT * FROM EMPLOYEES
ORDER BY DBMS_RANDOM.RANDOM();
--1.4 ORDER BY 랜덤 1~14(그 컬럼 순서대로 하게 된다)
SELECT * FROM EMPLOYEES
ORDER BY FLOOR(DBMS_RANDOM.VALUE(1, 14));
--1.5
--참고 이름이 3자리면 CHAR(문자)되나 4자리 이상 VARCHAR2...5 CHAR로 5문자
CREATE TABLE T_STUDENT(
    S_ID NUMBER(3) NOT NULL,
    S_NAME VARCHAR2(5 CHAR),
    S_GENDER CHAR(1 CHAR) DEFAULT 'M'
) SEGMENT CREATION IMMEDIATE;   --세그멘트하면 2부터 시작 안하고 1부터함
ALTER TABLE T_STUDENT
    ADD CONSTRAINT PK_T_STUDENT PRIMARY KEY (S_ID);
ALTER TABLE T_STUDENT
    ADD CONSTRAINT CK_T_STUDENT CHECK (S_GENDER IN ('M', 'F'));

DROP TABLE T_STUDENT;
DROP SEQUENCE SEQ_S_ID;
CREATE SEQUENCE SEQ_S_ID
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 999   --NUMBER(3)이라 세자리
NOCYCLE
NOCACHE;
--데이터 삽입.. 남자가 디폴트라 컬럼생략가능
SELECT * FROM T_STUDENT;
INSERT INTO T_STUDENT
VALUES (SEQ_S_ID.NEXTVAL, '임진희', 'F');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '이우찬');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '정진산');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '박인욱');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '하주성');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '민병욱');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '김동완');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '최규성');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (sEQ_S_ID.NEXTVAL, '권혁태');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '박태민');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '김성빈');
INSERT INTO T_STUDENT 
VALUES (SEQ_S_ID.NEXTVAL, '이예진', 'F');
INSERT INTO T_STUDENT 
VALUES (SEQ_S_ID.NEXTVAL, '박시연', 'F');
INSERT INTO T_STUDENT 
VALUES (SEQ_S_ID.NEXTVAL, '김소영', 'F');
INSERT INTO T_STUDENT 
VALUES (SEQ_S_ID.NEXTVAL, '주성진', 'F');
INSERT INTO T_STUDENT 
VALUES (SEQ_S_ID.NEXTVAL, '안수민', 'F');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '김선우');
INSERT INTO T_STUDENT
VALUES (SEQ_S_ID.NEXTVAL, '주민수', 'F');
INSERT INTO T_STUDENT (S_ID, S_NAME)
VALUES (SEQ_S_ID.NEXTVAL, '양석원');
COMMIT;
DESC T_STUDENT;
--19명 중에서 랜덤 한명 뽑기
--메인의 ROWNUM과 서브의 ROWNUM은 다르다. 트렌스포며 개입으로 DBMS_RANDOM.VALUE를 바꿨다.
--그래서 S_ID의 숫자가 바뀌더라도 알아서 처리해준다. 아래를 TOP-N-SQL이라고 한다.
SELECT ROWNUM, RN, S_NAME, S_GENDER
FROM (SELECT ROWNUM "RN", S_NAME, S_GENDER
        FROM T_STUDENT
        ORDER BY DBMS_RANDOM.VALUE())
WHERE ROWNUM = 1;

--2. ROLLUP
--기간별, 대출별, 대출구분별 롤업
SELECT GROUPING(PERIOD), PERIOD, GROUPING(GUBUN), GUBUN, SUM(LOAN_JAN_AMT)   --GROUPBY와 같은 컬럼을 셀렉트에 써야함
FROM KOR_LOAN_STATUS
WHERE PERIOD LIKE '2013%'
GROUP BY ROLLUP(PERIOD, GUBUN);--그룹바이 롤업으로 만든 데이터는 그룹핑에 1로 뜸

SELECT GROUPING(PERIOD), PERIOD, GROUPING(GUBUN), GUBUN, SUM(LOAN_JAN_AMT) 
FROM KOR_LOAN_STATUS
WHERE PERIOD LIKE '2013%'
GROUP BY PERIOD, ROLLUP(GUBUN); --PERIOD를 따로 빼면 전체 합계가 없다.
--GROUP BY ROLLUP(PERIOD), GUBUN; 으로 할시 내용이 달라짐

--2.1 2013년의 기간뱔, 용도별 대출금액 중에서 기타대추롸 가계담보대출 금액
SELECT *
FROM (SELECT GROUPING(PERIOD) GRP_PERIOD, PERIOD, GROUPING(GUBUN) GRP_GUBUN, GUBUN, SUM(LOAN_JAN_AMT)
        FROM KOR_LOAN_STATUS
        WHERE PERIOD LIKE '2013%'
        GROUP BY ROLLUP(PERIOD), GUBUN)
WHERE GRP_PERIOD = 1;

--2.2 CUBE..명시한 표현식 개수에 따라 모든 조합의 값을 구한다
SELECT GROUPING(PERIOD) GRP_PERIOD, PERIOD, GROUPING(GUBUN) GRP_GUBUN, GUBUN, SUM(LOAN_JAN_AMT)
        FROM KOR_LOAN_STATUS
        WHERE PERIOD LIKE '2013%'
        GROUP BY PERIOD, CUBE(GUBUN);
        
SELECT GROUPING(PERIOD) GRP_PERIOD, PERIOD, GROUPING(GUBUN) GRP_GUBUN, GUBUN, SUM(LOAN_JAN_AMT)
        FROM KOR_LOAN_STATUS
        WHERE PERIOD LIKE '2013%'
        GROUP BY CUBE(PERIOD, GUBUN);
        
--3. GROUPING SETS
SELECT GROUPING(PERIOD) GRP_PERIOD, PERIOD, GROUPING(GUBUN) GRP_GUBUN, GUBUN, SUM(LOAN_JAN_AMT)
        FROM KOR_LOAN_STATUS
        WHERE PERIOD LIKE '2013%'
        GROUP BY GROUPING SETS(PERIOD, GUBUN);
--3.1        
SELECT GROUPING(PERIOD), PERIOD, GROUPING(GUBUN), GUBUN, GROUPING(REGION), REGION, SUM(LOAN_JAN_AMT)
FROM KOR_LOAN_STATUS
WHERE PERIOD LIKE '2013%'
GROUP BY GROUPING SETS(PERIOD, GUBUN); 

SELECT GROUPING(PERIOD), PERIOD, GROUPING(GUBUN), GUBUN, GROUPING(REGION), REGION, SUM(LOAN_JAN_AMT)
FROM KOR_LOAN_STATUS
WHERE PERIOD LIKE '2013%'
AND REGION IN ('서울', '경기')
GROUP BY GROUPING SETS(PERIOD, (GUBUN, REGION));

--4. JOIN
--EMPLOYEE하고 DEPARTMENTS 조인..두 테이블과 안겹치는건 앨리어스 필요없대
DESC DEPARTMENTS;
DESC EMPLOYEES;
SELECT A.EMPLOYEE_ID, A.EMP_NAME, B.DEPARTMENT_ID, B.DEPARTMENT_NAME
FROM EMPLOYEES A JOIN DEPARTMENTS B ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID); 

--4.1 위의 것을 오라클 SQL..동등조인(오라클에서만 되는게 오라클SQL)으로
SELECT A.EMPLOYEE_ID, A.EMP_NAME, B.DEPARTMENT_ID, B.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID; --WHERE가 조인 조건을 대신함

--5. SEMI JOIN 에서 IN 쓰는거
SELECT * FROM EMPLOYEES A 
WHERE A.DEPARTMENT_ID IN (SELECT B.DEPARTMENT_ID    --20, 70 넘어가서 IN에 들어가 부서이름 찾음
                          FROM DEPARTMENTS B
                          WHERE B.DEPARTMENT_NAME IN ('마케팅', '홍보부'));
--5.1
SELECT * FROM DEPARTMENTS; 
SELECT * FROM JOBS;

SELECT A.EMPLOYEE_ID, A.EMP_NAME, A.DEPARTMENT_ID, A.JOB_ID
FROM EMPLOYEES A 
WHERE A.DEPARTMENT_ID IN (SELECT B.DEPARTMENT_ID   
                          FROM DEPARTMENTS B
                          WHERE B.DEPARTMENT_NAME IN ('영업부'));

--6. 셀프조인
SELECT * 
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID; /*직원 ID 107건과 직원아이디 107건 연결했는데 나온건 106건
ID 100번인 스티븐킹은 MANAGER_ID가 NULL(젤 위인 사장이라)..MANAGER_ID와 EMPLOYEE_ID 연결인데
사장 매니터아이디 NULL과 사원아이디 100이 연결이 안됨..그래서 사장 빠진 106건 */
SELECT A.EMPLOYEE_ID, A.EMP_NAME, A.MANAGER_ID, B.EMP_NAME "MGR_NAME"
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID; 
--100번 사장을 사번, 이름 빼고 다 널로 바꾸면 사장이 뜨겠지 이게 OUTER JOIN..그동안 한건 INNER JOIN
--+를 사장이 없는 B쪽 아이디에 넣음
SELECT A.EMPLOYEE_ID, A.EMP_NAME, A.MANAGER_ID, B.EMP_NAME "MGR_NAME"
FROM EMPLOYEES A, EMPLOYEES B
WHERE A.MANAGER_ID = B.EMPLOYEE_ID(+); 
--ANSI JOIN으로 바꿈..기준이 왼쪽이라 LEFT OUTER JOIN으로 연결..나머지를 NULL로 채움
SELECT A.EMPLOYEE_ID, A.EMP_NAME, A.MANAGER_ID, B.EMP_NAME "MGR_NAME"
FROM EMPLOYEES A LEFT OUTER JOIN EMPLOYEES B ON (A.MANAGER_ID = B.EMPLOYEE_ID);
--6.1 FULL OUTER JOIN...마지막에 부서없는 킴벌리가 FULL OUTER JOIN으로 뜬거래
SELECT B.DEPARTMENT_NAME, A.EMPLOYEE_ID, A.EMP_NAME
FROM EMPLOYEES A FULL OUTER JOIN DEPARTMENTS B ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID)
ORDER BY B.DEPARTMENT_NAME;
--6.2 오라클엔 FULL OUTER JOIN이 없으니 UNION을 쓴다..중간에 같은 것도 존재하니까 행의 중복을 배제해야..UNION ALL은 같은 행도 나와서 안됨.
--UNION과 UNION ALL 비교하기 중요함..
--EQUI JOIN한게 겹친거래
SELECT B.DEPARTMENT_NAME, A.EMPLOYEE_ID, A.EMP_NAME 
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID(+) = B.DEPARTMENT_ID
UNION
SELECT B.DEPARTMENT_NAME, A.EMPLOYEE_ID, A.EMP_NAME 
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID(+);

--6.3 문제 모든 직원의 모든 직무를 표시한다. (직무 없는 사람이라도 나와야)
-- ANSI SQL
SELECT A.EMPLOYEE_ID, A.EMP_NAME, A.JOB_ID, B.JOB_TITLE
FROM EMPLOYEES A FULL OUTER JOIN JOBS B ON (A.JOB_ID = B.JOB_ID);

-- ORACLE SQL
SELECT EMPLOYEE_ID, EMP_NAME, A.JOB_ID, B.JOB_TITLE
FROM EMPLOYEES A, JOBS B
WHERE A.JOB_ID(+) = B.JOB_ID
UNION
SELECT EMPLOYEE_ID, EMP_NAME, A.JOB_ID, B.JOB_TITLE
FROM EMPLOYEES A, JOBS B
WHERE A.JOB_ID = B.JOB_ID(+);

-- 양쪽에 빠진 데이터가 없을 경우 OUTER JOIN의 COST가 높을 수 있다.
-- 따라서 이 경우 INNER JOIN으로 바꿔주는것도 좋다