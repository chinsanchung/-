desc employees;
--평균 구하기..round로 소수점 둘째에서 반올림, avg를 썼지만 그룹핑이 아닌 전체를 대상으로 해서 그룹바이 안씀
select round(avg(salary), 2) "Agv_sal"
from employees;
--select 연습하기
--1. 모든 사원의 연봉 구하기
select EMP_NAME, SALARY, salary * 12 "Annual_SALARY"  
from employees;
SELECT * FROM EMPLOYEES;
--2. 연봉이 10만불 이상인 직원의 정보를 조회하기
select EMPLOYEE_ID, EMP_NAME, SALARY, JOB_ID, DEPARTMENT_ID, SALARY * 12 "ANNUAL_SALARY"
FROM EMPLOYEES
WHERE SALARY * 12 >= 100000;       --*12로 하면 컬럼이 변형됨. 샐러리가 인덱스였으면 변형으로 못 썼을것.
--WHERE SALARY >= 100000 / 12; --이럴시 컬럼 변형 없이 사용 가능하다.

--3. 인덱스 만들어서 변형을 알아보자. 계획설명에서 보면 인덱스가 변형됐다고 뜬대
CREATE INDEX IX_EMPLOYEES_SALARY ON EMPLOYEES(SALARY);
select EMPLOYEE_ID, EMP_NAME, SALARY, JOB_ID, DEPARTMENT_ID, SALARY * 12 "ANNUAL_SALARY"
FROM EMPLOYEES
WHERE SALARY * 12 >= 100000;
DROP INDEX IX_EMPLOYEES_SALARY;
--4. 인덱스 변형 CUSTOMERS로 알아보기
SELECT CUST_ID, CUST_NAME, CUST_YEAR_OF_BIRTH, CUST_CREDIT_LIMIT, --2017 - CUST_YEAR_OF_BIRTH "YEAR"
FROM CUSTOMERS;
--TO CHAR로 좌측부터 글이 나온다. 그리고 만으로 연령계산(월, 일 정보가 없어서 만들어주고 데이터타입으로 바꿈, 
--먼스비트윈으로 월계산->12로 나누고 플로어로 나눈 값의 소수점 없앰
SELECT CUST_ID, CUST_NAME, CUST_YEAR_OF_BIRTH,
FLOOR(MONTHS_BETWEEN(SYSDATE , TO_DATE(TO_CHAR(CUST_YEAR_OF_BIRTH) || '-01-01', 'YYYY-MM-DD')) / 12) "AGE",
CUST_CREDIT_LIMIT
FROM CUSTOMERS;
--5. CREDIT_LIMIT로 인덱스 연습용
CREATE INDEX IX_CUSTOMERS_CUST_CREDIT_LIMIT ON CUSTOMERS(CUST_CREDIT_LIMIT);
SELECT /*+ INDEX(CUSTOMERS IX_CUSTOMERS_CUST_CREDIT_LIMIT)*/   --인덱스를 무조건 쓰게 만드는 용어(어려운거니까 알 필요X)
CUST_ID, CUST_NAME, CUST_YEAR_OF_BIRTH,
FLOOR(MONTHS_BETWEEN(SYSDATE , TO_DATE(TO_CHAR(CUST_YEAR_OF_BIRTH) || '-01-01', 'YYYY-MM-DD')) / 12) "AGE",
CUST_CREDIT_LIMIT
FROM CUSTOMERS WHERE CUST_CREDIT_LIMIT > 100000 / 12;   --결론: WHERE조건절에 컬럼은 변형안하고 쓰는게 좋다

--6. 연봉이 10만불 이상, SA_REP를 수행하는 직원들의 정보(사번, 이름, 부서, 직무, 연봉)를 연봉이 큰 순서로 조회하기
SELECT EMPLOYEE_ID, EMP_NAME, DEPARTMENT_ID, JOB_ID, SALARY * 12 "ANNUAL_SALARY"
FROM EMPLOYEES
WHERE SALARY >= 100000 / 12 AND JOB_ID = 'SA_REP'
ORDER BY "ANNUAL_SALARY" DESC;
--DEPARTMENT_ID 80이 뭘까
SELECT * FROM JOBS;
--7. 부서아이디 80번이 영업부로 나오도록 만들자
SELECT A.EMPLOYEE_ID, A.EMP_NAME, B.DEPARTMENT_NAME, A.JOB_ID, SALARY * 12 "ANNUAL_SALARY"
FROM EMPLOYEES A JOIN DEPARTMENTS B ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID)
WHERE SALARY >= 100000 / 12 AND JOB_ID = 'SA_REP'
ORDER BY "ANNUAL_SALARY" DESC;
--8. JOB_ID의 이름이 나오게 하기
SELECT A.EMPLOYEE_ID, A.EMP_NAME, B.DEPARTMENT_NAME, C.JOB_TITLE, A.SALARY * 12 "ANNUAL_SALARY"
FROM EMPLOYEES A JOIN DEPARTMENTS B ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID)
                 JOIN JOBS C ON (A.JOB_ID = C.JOB_ID)
WHERE A.SALARY >= 100000 / 12 AND C.JOB_ID = 'SA_REP'
ORDER BY "ANNUAL_SALARY" DESC;
--9. INSERT INTO ~SELECT 알아보기
--EMPLOYEES에서 가져오기
CREATE TABLE T_EMPLOYEES_SALARY_OVER_5000
AS
SELECT EMPLOYEE_ID, EMP_NAME, DEPARTMENT_ID, JOB_ID, SALARY
FROM EMPLOYEES
WHERE 1 = 0;           --구조만 복사하겠다는 의미
DESC T_EMPLOYEES_SALARY_OVER_5000;

ALTER TABLE T_EMPLOYEES_SALARY_OVER_5000
    ADD CONSTRAINT PK_T_EMPLOYEES PRIMARY KEY (EMPLOYEE_ID);
--입력한 제약조건 확인해보기
SELECT * FROM V_CONSTRAINTS_COLUMNS WHERE TABLE_NAME = 'T_EMPLOYEES_SALARY_OVER_5000';
--데이터 입력. SELECT에서 컬럼들 적기.
INSERT INTO T_EMPLOYEES_SALARY_OVER_5000
SELECT EMPLOYEE_ID, EMP_NAME, DEPARTMENT_ID, JOB_ID, SALARY
FROM EMPLOYEES WHERE SALARY > 5000;
COMMIT;
--결과 보기
SELECT * FROM T_EMPLOYEES_SALARY_OVER_5000;
--10. 업데이트문으로 직원들 연봉 20% 인상하기
--원본 건드리지 말고..N_YEAR, NN_YEAR, NNN_YEAR 컬럼-NUMBER(10) 세개 추가
ALTER TABLE EMPLOYEES
    ADD (N_YEAR NUMBER(8, 2),
        NN_YEAR NUMBER(8, 2), 
        NNN_YEAR NUMBER(8, 2)); --복수일 경우 ADD(~~~) 묶어서 하기. 소수점도 있어서 (8, 2)
DESC EMPLOYEES;
-- 업데이트하기..이거 입력 안하고 넘어감
UPDATE EMPLOYEES
SET N_YEAR = SALARY +(SALARY * 0.2),
    NN_YEAR = (SALARY +(SALARY * 0.2)) + ((SALARY +(SALARY * 0.2))*0.2)
    NNN_YEAR = (SALARY +(SALARY * 0.2)) + ((SALARY +(SALARY * 0.2))*0.2) +
               ((SALARY +(SALARY * 0.2)) + ((SALARY +(SALARY * 0.2)) * 0.2) * 0.2);
SELECT EMPLOYEE_ID, EMP_NAME, SALARY, N_YEAR, NN_YEAR, NNN_YEAR FROM EMPLOYEES;
--DROP하기 N, NN, NNN
ALTER TABLE EMPLOYEES
    DROP COLUMN NNN_YEAR;
--11. DISTICNT는 행의 중복을 배제하는 키워드.
SELECT DISTINCT COMMISSION_PCT
FROM EMPLOYEES;
--11-1. 커미션 받는 사람들을 조회해보자
SELECT EMPLOYEE_ID, EMP_NAME, JOB_ID, DEPARTMENT_ID, COMMISSION_PCT
FROM EMPLOYEES;
--WHERE COMMISSION_PCT IS NOT NULL;  --WHERE COMMISSION != NULL;이 안되는 이유: 데이터가 존재해야 비교하는데 NULL은 존재하지 않아서.
--11-2 커미션 받는 사람들=NOT NULL은 연봉 = 12달 월급과 매달 월급의 커미션요율 을 적용해 계산한다.
--SELECT NVL2(NULL, 'NOT NULL', 'IS NULL') FROM DUAL; 힌트
--SELECT NVL2(1=NOT NULL, 'NOT NULL', 'IS NULL') FROM DUAL; 힌트
SELECT EMPLOYEE_ID, EMP_NAME, JOB_ID, DEPARTMENT_ID, COMMISSION_PCT,
        NVL2(COMMISSION_PCT, SALARY * 12 + SALARY * 12 * COMMISSION_PCT, SALARY * 12) "ANNUAL_SALARY"
FROM EMPLOYEES;
--NVL로 해보기
SELECT EMPLOYEE_ID, EMP_NAME, NVL(COMMISSION_PCT, 0), COMISSION_PCT, SALARY,
        SALARY * 12 * (1 + NVL(COMMISSION_PCT, 0)) "연봉" FROM EMPLOYEES;

--12. MERGE문 연습하기 102쪽. 기간동안의 판매실적있는 사원..DISTINCT 아니면 GROUP BY A.EMPLOYEE_ID로 하면 사원 번호 중복 제거
CREATE TABLE EX3_3(
    EMPLOYEE_ID NUMBER,
    BONUS_AMT NUMBER DEFAULT 0
    );
INSERT INTO EX3_3 (EMPLOYEE_ID)
SELECT DISTINCT A.EMPLOYEE_ID
FROM EMPLOYEES A JOIN SALES B ON (A.EMPLOYEE_ID = B. EMPLOYEE_ID)
WHERE B.SALES_MONTH BETWEEN '200010' AND '200012';
SELECT * FROM EX3_3; --직원ID 미리 적어둠 148, 153, 154, 155, 161,
COMMIT;
--12.1 MERGE 실습 2 바로 위와 비교해 161번 겹치는데 161은 급여 1% 보너스해서 BONUS_AMT에 반영시키기
--만약 일치하지 않으면 신규로 입력하되 보너스_AMT는 0.1%로 보너스 계산
SELECT * FROM EMPLOYEES WHERE MANAGER_ID = 146; --직원ID 미리 적어둠 156, 157, 158, 159, 160, 161
--관리자 ID가 146이고 EX_3_3에 없는 사람들을 조회하는 쿼리
SELECT EMPLOYEE_ID, EMP_NAME, SALARY, SALARY * 0.001
FROM EMPLOYEES 
WHERE MANAGER_ID = 146
AND EMPLOYEE_ID NOT IN (SELECT EMPLOYEE_ID FROM EX3_3);
--관리자 ID가 146이고 EX_3_3에 있는 사람들을 조회하는 쿼리
SELECT EMPLOYEE_ID, EMP_NAME, SALARY, SALARY * 0.01
FROM EMPLOYEES 
WHERE MANAGER_ID = 146
AND EMPLOYEE_ID IN (SELECT EMPLOYEE_ID FROM EX3_3); --SELECT안에 넣은것이 안에 있어서 서브쿼리. 데이터 161을 만들어준 쿼리.
--나머지 148, 153, 154, 155, 161은 0.1% 보너스
--12.2 서브쿼리연습
--기억할 명제: WHERE절의 서브쿼리는 FROM절의 JOIN으로 해결가능하다
SELECT A.EMPLOYEE_ID, A.EMP_NAME, A.SALARY, A.SALARY * 0.01
FROM EMPLOYEES A JOIN EX3_3 B ON (A.EMPLOYEE_ID = B.EMPLOYEE_ID)
WHERE A.MANAGER_ID = 146;

--13. 서브쿼리 문제. 사원들의 평균 급여보다 많이 받는 사원의 정보(사번, 이름, 직무, 부서, 급여)를 조회하시오
SELECT ROUND(AVG(SALARY), 0) FROM EMPLOYEES; --평균 급여. 서브쿼리
--인라인뷰 서브쿼리 버젼. 값 딱 하나만 반환한 서브쿼리는 SCALAR SUBQUERY
SELECT EMPLOYEE_ID, EMP_NAME, JOB_ID, DEPARTMENT_ID, SALARY
FROM EMPLOYEES
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES)
ORDER BY SALARY;

--13-1. WHERE절의 서브쿼리는 FROM절의 JOIN으로 해결가능하다와 같은 소리..13과 같은 결과
--연결을 조건 없이(B 테이블 없음) 하는 인라인뷰 CROSS JOIN 버젼: 데카르트곱 만듬..반드시 " "를 넣어야 한다.
SELECT A.EMPLOYEE_ID, A.EMP_NAME, A.JOB_ID, A.DEPARTMENT_ID, A.SALARY, B.AVG_SAL
FROM EMPLOYEES A CROSS JOIN (SELECT AVG(SALARY) "AVG_SAL" FROM EMPLOYEES) B
WHERE A.SALARY > B.AVG_SAL
ORDER BY A.SALARY;

--13-2 3번째 식. 이 서브쿼리를 IN-LINE VIEW라고 부른다. FROM절에 게시한 것.
--인라인뷰 JOIN~ON 버젼. 
SELECT A.EMPLOYEE_ID, A.EMP_NAME, A.JOB_ID, A.DEPARTMENT_ID, A.SALARY, B.AVG_SAL
FROM EMPLOYEES A JOIN (SELECT AVG(SALARY) "AVG_SAL" FROM EMPLOYEES) B
                ON (A.SALARY > B.AVG_SAL)
WHERE A.SALARY > B.AVG_SAL
ORDER BY A.SALARY;

--14. 위의 것 MERGE. 146번 사람들 조인
SELECT * FROM EX3_3;
MERGE INTO EX3_3 A
USING (SELECT EMPLOYEE_ID, SALARY, MANAGER_ID
        FROM EMPLOYEES WHERE MANAGER_ID = 146) B
    ON (A.EMPLOYEE_ID = B.EMPLOYEE_ID)
WHEN MATCHED THEN
    UPDATE SET A.BONUS_AMT = A.BONUS_AMT + B.SALARY * 0.01        --UPDATE 161번
WHEN NOT MATCHED THEN                                             --INSERT 161 아닌것
    INSERT VALUES(B.EMPLOYEE_ID, B.SALARY* 0.001);
    