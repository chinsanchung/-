--1. 상위부서가 90의 평균급여
DESC DEPARTMENTS;
--1.1 부서별 서브쿼리로 상위부서
SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE PARENT_ID = 90;
SELECT  DEPARTMENT_ID, ROUND(AVG(SALARY), 2) AVG_SAL
FROM EMPLOYEES 
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
                        FROM DEPARTMENTS
                        WHERE PARENT_ID = 90)
GROUP BY DEPARTMENT_ID;
--1.2 조인으로 하기
SELECT A.DEPARTMENT_ID, ROUND(AVG(B.SALARY), 2) AVG_SAL
FROM DEPARTMENTS A JOIN EMPLOYEES B ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID)
WHERE A.PARENT_ID = 90
GROUP BY A.DEPARTMENT_ID;
--1.3 상위 부서가 기획부인 모든 사원의 급여를 자신의 부서별 평균급여로 갱신하는 쿼리
UPDATE EMPLOYEES A
SET SALARY = (SELECT AVG_SAL
              FROM (SELECT  A.DEPARTMENT_ID, ROUND(AVG(B.SALARY), 2) AVG_SAL
                    FROM DEPARTMENTS A JOIN EMPLOYEES B ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID)
                    WHERE A.PARENT_ID = 90
                    GROUP BY A.DEPARTMENT_ID) B
              WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID)
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
                        FROM DEPARTMENTS
                        WHERE PARENT_ID = 90);
ROLLBACK;
--1.4 90번 상위부서 직원 가운데서 평균급여보다 많은 급여를 받는 사람들
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS WHERE PARENT_ID = 90;
--평균 급여
SELECT ROUND(AVG(B.SALARY), 2) FROM DEPARTMENTS A JOIN EMPLOYEES B ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID)
       WHERE A.PARENT_ID = 90;
--방법1       
SELECT A.DEPARTMENT_ID, A.PARENT_ID, B.SALARY
FROM DEPARTMENTS A JOIN EMPLOYEES B ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID)
WHERE A.PARENT_ID = 90
      AND B.SALARY > (SELECT ROUND(AVG(B.SALARY), 2) 
                      FROM DEPARTMENTS A JOIN EMPLOYEES B ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID)
                      WHERE A.PARENT_ID = 90);
--방법2 SQL 오라클 JOIN
SELECT A.EMPLOYEE_ID, A.EMP_NAME, B.DEPARTMENT_ID, B.DEPARTMENT_NAME, A.SALARY
FROM EMPLOYEES A, DEPARTMENTS B, (SELECT AVG(B.SALARY) "AVG_SALARY"
                                  FROM DEPARTMENTS A, EMPLOYEES B WHERE A.PARENT_ID = 90 AND A.DEPARTMENT_ID = B.DEPARTMENT_ID) C
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID AND A.SALARY > C.AVG_sALARY
AND B.PARENT_ID = 90;

--1.5 90번 산하부서의 부서원 중에서 부서별 평균이상의 급여를 받는 부서원 조회
/*SELECT *
FROM DEPARTMENTS 
WHERE PARENT_ID = 90;
--90번 산하부서 부서별 평균급여
SELECT A.DEPARTMENT_ID, AVG(B.SALARY)
FROM DEPARTMENTS A JOIN EMPLOYEES B ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID)
WHERE A.PARENT_ID = 90 
GROUP BY A.DEPARTMENT_ID;*/
--순서 직원 평균 급여 -> 90번 산하부서 -> 결과
SELECT A.EMPLOYEE_ID, A.EMP_NAME, A.DEPARTMENT_ID, A.SALARY
FROM EMPLOYEES A JOIN (SELECT DEPARTMENT_ID, AVG(SALARY) "AVG_SAL"
                       FROM EMPLOYEES
                       GROUP BY DEPARTMENT_ID) B
                 ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID AND A.SALARY >= B.AVG_SAL)  --조인조건 두개..여기까지가 부서별 평균급여 넘는 사람들
WHERE A.DEPARTMENT_ID IN (SELECT DEPARTMENT_ID  --WHERE ~~값이 하나면 "=" 여러개일시 IN으로
                          FROM DEPARTMENTS
                          WHERE PARENT_ID = 90)   --90번 산하부서인 사람들
ORDER BY A.DEPARTMENT_ID, A.SALARY DESC;

--1.6 기획부 산하부서의 부선원 중 2017년 7월 1일 기준 평균 근속 연수 이상 근무한 부서원 조회
--기획부 산하부서 구하기->모든 사원들의 근속연수 구하기->
/*
--1) 기획부 조회
SELECT * FROM DEPARTMENTS;
--2) 기획부 산하 부서
SELECT * FROM DEPARTMENTS WHERE PARENT_ID = 90;
--3)평균 근속 연수
DESC EMPLOYEES;
--
SELECT EMP_NAME, HIRE_dATE, FLOOR(MONTHS_BETWEEN('2017-07-01' ,HIRE_DATE) / 12) "근속연수"
FROM EMPLOYEES;*/
--1) 기획부 찾기
SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = '기획부';
--2) 산하부서찾기
SELECT DEPARTMENT_ID FROM DEPARTMENTS
WHERE PARENT_ID = (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = '기획부');
/*--3) 산하부서에 속해 있는 직원...결과적으로 필요없었음
SELECT * 
FROM EMPLOYEES A JOIN (SELECT DEPARTMENT_ID FROM DEPARTMENTS
                       WHERE PARENT_ID = (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = '기획부')) B
                 ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID);*/
--4)모든 직원들의 정보, 근속연수 ...중간값이니까 FLOOR니 데이터조작하지 말기
SELECT EMP_NAME, DEPARTMENT_ID, MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12 "WORD_YEAR"
FROM EMPLOYEES;
--5) 관련부서 직원만 보이게
SELECT EMP_NAME, DEPARTMENT_ID, MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12 "WORK_YEAR"
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS
                        WHERE PARENT_ID = (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = '기획부'));
--6) 기획부 직원들 평균 근속연수
SELECT AVG(MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12) "AVG_WORK_YEAR"
FROM EMPLOYEES 
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS
                        WHERE PARENT_ID = (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = '기획부'));
--7) 이들의 근속연수와 평균 근속연수 이상 근무한 직원 비교
SELECT EMP_NAME, DEPARTMENT_ID, 
       FLOOR(MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12) "WORK_YEAR", AVG_WORK_YEAR
FROM EMPLOYEES A JOIN (SELECT AVG(MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12) "AVG_WORK_YEAR"
                       FROM EMPLOYEES 
                       WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS
                                               WHERE PARENT_ID = 
                                               (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = '기획부'))) B
                       ON (MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), A.HIRE_DATE) / 12) >= AVG_WORK_YEAR
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS
                        WHERE PARENT_ID = (SELECT DEPARTMENT_ID 
                                           FROM DEPARTMENTS 
                                           WHERE DEPARTMENT_NAME = '기획부'));

--8) 결과
SELECT EMP_NAME, DEPARTMENT_ID, 
       FLOOR(MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12) "WORK_YEAR"
FROM EMPLOYEES A JOIN (SELECT AVG(MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12) "AVG_WORK_YEAR"
                             FROM EMPLOYEES
                             WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
                                                     FROM DEPARTMENTS
                                                     WHERE PARENT_ID = (SELECT DEPARTMENT_ID 
                                                                        FROM DEPARTMENTS 
                                                                        WHERE DEPARTMENT_NAME = '기획부'))) B 
                        ON (MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), A.HIRE_DATE) / 12 >= AVG_WORK_YEAR)                                              
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
                        FROM DEPARTMENTS
                        WHERE PARENT_ID = (SELECT DEPARTMENT_ID 
                                           FROM DEPARTMENTS 
                                           WHERE DEPARTMENT_NAME = '기획부'))
ORDER BY DEPARTMENT_ID, WORK_YEAR DESC, EMP_NAME;
--9)JOIN으로 조금이나마 깔끔하게
SELECT A.EMP_NAME, A.DEPARTMENT_ID, 
       FLOOR(MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12) "WORK_YEAR"
FROM EMPLOYEES A JOIN (SELECT AVG(MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12) "AVG_WORK_YEAR"
                             FROM EMPLOYEES A JOIN (SELECT DEPARTMENT_ID
                                                     FROM DEPARTMENTS
                                                     WHERE PARENT_ID = (SELECT DEPARTMENT_ID 
                                                                        FROM DEPARTMENTS 
                                                                        WHERE DEPARTMENT_NAME = '기획부')) B
                                               ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID))
                        ON (MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), A.HIRE_DATE) / 12 >= AVG_WORK_YEAR) 
                        JOIN (SELECT DEPARTMENT_ID
                        FROM DEPARTMENTS 
                        WHERE PARENT_ID = (SELECT DEPARTMENT_ID 
                                           FROM DEPARTMENTS 
                                           WHERE DEPARTMENT_NAME = '기획부')) C --INLINE VIEW
                        ON (A.DEPARTMENT_ID = C.DEPARTMENT_ID)
ORDER BY DEPARTMENT_ID, WORK_YEAR DESC, EMP_NAME;
--9-1) 다른 조인 셀프조인..
SELECT A.EMP_NAME, A.DEPARTMENT_ID, 
       FLOOR(MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12) "WORK_YEAR"
FROM EMPLOYEES A JOIN (SELECT AVG(MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), HIRE_DATE) / 12) "AVG_WORK_YEAR"
                             FROM EMPLOYEES A JOIN (SELECT A.DEPARTMENT_ID
                                                    FROM DEPARTMENTS A JOIN DEPARTMENTS B ON (A.PARENT_ID = B.DEPARTMENT_ID)
                                                    WHERE B.DEPARTMENT_NAME = '기획부') B
                                               ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID))
                        ON (MONTHS_BETWEEN(TO_DATE('2017-07-01', 'YYYY-MM-DD'), A.HIRE_DATE) / 12 >= AVG_WORK_YEAR) 
                        JOIN (SELECT A.DEPARTMENT_ID
                              FROM DEPARTMENTS A JOIN DEPARTMENTS B ON (A.PARENT_ID = B.DEPARTMENT_ID)
                              WHERE B.DEPARTMENT_NAME = '기획부') C --INLINE VIEW
                        ON (A.DEPARTMENT_ID = C.DEPARTMENT_ID)
ORDER BY DEPARTMENT_ID, WORK_YEAR DESC, EMP_NAME;

--2. 계층형 쿼리
--START WITH은 제일 꼭대기 조건이 들어감..CONNECT BY에서 MANAGER_ID가 상위라 임플로이아이디에 PRIOR 넣음
--LEVEL을 넣어 순서 알아보고 LPAD로
SELECT EMPLOYEE_ID, EMP_NAME, LEVEL
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;     --=MANAGER_ID = EMPLOYEE_ID
--LEVEL을 넣어 순서 알아보고 LPAD로
SELECT EMPLOYEE_ID, LPAD(' ', 4 * (LEVEL - 1)) || EMP_NAME "ENAME", LEVEL
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;

--2.1 부서정보 출력
SELECT EMPLOYEE_ID, DEPARTMENT_ID, LPAD(' ', 2 * (LEVEL - 1)) || EMP_NAME "ENAME", LEVEL
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;
--WHERE 없이 100을 출력하면 이상하게 뜨네..행제약조건 권창.
--대신
SELECT EMPLOYEE_ID, DEPARTMENT_ID, LPAD(' ', 2 * (LEVEL - 1)) || EMP_NAME "ENAME", LEVEL
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
AND DEPARTMENT_ID = 90;

--2.2 SIBLINGS BY 같은 레벨끼리 소트를 시켜줌
SELECT EMPLOYEE_ID, DEPARTMENT_ID, LPAD(' ', 2 * (LEVEL - 1)) || EMP_NAME "ENAME", LEVEL
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
ORDER SIBLINGS BY DEPARTMENT_ID;

--2.3 CONNECT_BY_ISLEAF
SELECT EMPLOYEE_ID, DEPARTMENT_ID, LPAD(' ', 2 * (LEVEL - 1)) || EMP_NAME "ENAME", LEVEL,
       CONNECT_BY_ROOT DEPARTMENT_ID AS ROOT, CONNECT_BY_ISLEAF,
       SYS_CONNECT_BY_PATH(DEPARTMENT_ID, '/') PATH
FROM EMPLOYEES
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID
ORDER SIBLINGS BY DEPARTMENT_ID;

--3. P.221~ 계층형 쿼리 응용
--2016년 1월~12월까지 각 월마다 1000건의 데이터를 생성해라 매일 천건=12000
SELECT TO_DATE('2016-' || LPAD(CEIL(ROWNUM/1000), 2, '0'), 'YYYY-MM') COL1, FLOOR(DBMS_RANDOM.VALUE(5000, 6000)) COL2, 3 COL3
FROM DUAL
CONNECT BY LEVEL <= 12000;

--4. WITH 절
--연도별 최종월 기준 매출이 가장 많은 도시와 그 잔액을 조회하기
--1) 각 연도의 최종월
SELECT MAX(PERIOD)
FROM KOR_LOAN_STATUS
GROUP BY SUBSTR(PERIOD, 1, 4);
--2) 연도별 도시 대출 합
SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) TOTAL
FROM KOR_LOAN_STATUS
GROUP BY PERIOD, REGION;
--3)일단은 총매출
SELECT A.MAX_PERIOD, MAX(TOTAL) MAX_LOAN_JAN_AMT
FROM (SELECT MAX(PERIOD) MAX_PERIOD
      FROM KOR_LOAN_STATUS
      GROUP BY SUBSTR(PERIOD, 1, 4)) A
      JOIN
      (SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) TOTAL
       FROM KOR_LOAN_STATUS
       GROUP BY PERIOD, REGION) B
       ON (A.MAX_PERIOD = B.PERIOD)
GROUP BY A.MAX_PERIOD;
--4)합계                   
WITH X AS (SELECT PERIOD, REGION, SUM(LOAN_JAN_AMT) TOTAL
          FROM KOR_LOAN_STATUS
          GROUP BY PERIOD, REGION),
     Y AS (SELECT A.MAX_PERIOD, MAX(TOTAL) MAX_LOAN_JAN_AMT
          FROM (SELECT MAX(PERIOD) MAX_PERIOD
                FROM KOR_LOAN_STATUS
                GROUP BY SUBSTR(PERIOD, 1, 4)) A
       JOIN X ON (A.MAX_PERIOD = X.PERIOD)
       GROUP BY A.MAX_PERIOD)
SELECT X.PERIOD, X.REGION, X.TOTAL 
FROM X JOIN Y ON (X.PERIOD = Y.MAX_PERIOD AND X.TOTAL = Y.MAX_LOAN_JAN_AMT);

--5. 분석함수..ROW_NUMBER, RANK, DENSE_RANK
--5.1 부서아이디별 월급 많은 순으로..현재 ROWNUM이 제기능 못함
SELECT ROWNUM, EMPLOYEE_ID, EMP_NAME, SALARY
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID, EMP_NAME, SALARY DESC;
--PATITION 지정, ROWNUM 사용
SELECT DEPARTMENT_ID, ROW_NUMBER() OVER (PARTITION BY DEPARTMENT_ID
                          ORDER BY DEPARTMENT_ID, EMP_NAME) "ROWNUM",
       EMP_NAME, SALARY
FROM EMPLOYEES;
--SALARY로 정렬..ROW NUMBER 대신 RANK도 가능하다.(RANK는 공동순위 2위 2위 다음은 3위X 4위) DENSE_RANK는 2위 2위 다음 3위
SELECT DEPARTMENT_ID, DENSE_RANK() OVER (PARTITION BY DEPARTMENT_ID
                          ORDER BY DEPARTMENT_ID, SALARY DESC) "RANK",
       EMP_NAME, SALARY
FROM EMPLOYEES;

--각 부서별로 3위만
SELECT *
FROM (SELECT DEPARTMENT_ID, DENSE_RANK() OVER (PARTITION BY DEPARTMENT_ID
                          ORDER BY DEPARTMENT_ID, SALARY DESC) "RANK",
       EMP_NAME, SALARY
FROM EMPLOYEES) A
WHERE RANK = 3;

--5. 다중 테이블 INSERT
CREATE TABLE EX7_3(
        EMP_ID NUMBER,
        EMP_NAME VARCHAR2(100));
CREATE TABLE EX7_4(
        EMP_ID NUMBER,
        EMP_NAME VARCHAR2(100));
--ALL로 할려면 뒤에 반드시 SELECT * FROM DUAL;을 써야함
INSERT ALL
    INTO EX7_3 VALUES(100, '김동환')
    INTO EX7_3 VALUES(100, '민병욱')
    INTO EX7_3 VALUES(100, '하주성')
SELECT * 
FROM DUAL;

SELECT * FROM EX7_3;
ROLLBACK;

--5.1 부서에 따라 다른 테이블에 가도록하기
INSERT ALL
WHEN DEPARTMENT_ID = 30 THEN
    INTO EX7_3 VALUES(EMPLOYEE_ID, EMP_NAME)
WHEN DEPARTMENT_ID = 90 THEN
    INTO EX7_4 VALUES(EMPLOYEE_ID, EMP_NAME)
SELECT DEPARTMENT_ID, EMPLOYEE_ID, EMP_NAME
FROM EMPLOYEES;
SELECT * FROM EX7_4;
ROLLBACK;
